GeoImageConverter
v 0.4.0a

Copyright © 2017-2018 Александр (Sagrer) Гриднев
sagrer@yandex.ru

Сайт программы: http://personal.sagrer.ru/tracs/geoimgconv

Программа распространяется на условиях лицензии GNU GPL v3 или выше,
см. файл gpl.txt

Об условиях распространения используемых в программе библиотек - см.
файл libs_licenses.txt
_______________________________________________________________

	В данном файле содержится инструкция по сборке программы из исходников
под Windows.

	В данный момент поддерживается сборка в следующих IDE и компилляторах:
	
	* gcc (в т.ч. MinGW из MSYS2). Для возможной работы над исходником генерируется файл
проекта для Code::Blocks.
	* Microsoft Visual Studio 2015 Community Edition.
	* Microsoft Visual Studio 2017 Community Edition.

	Программа поставляется с make-файлом стандартного для GNU Make формата, но он будет
работать только если в системе установлены в стандартные места dev-версии всех необходимых
библиотек, иначе СMake не сможет найти зависимости. Поэтому в комплекте с
исходниками идут несколько bat-скриптов, с помощью которых можно запустить как
сборку из исходников нужных библиотек, так и сборку самой программы. Для их работы
нужно предварительно установить несколько переменных окружения.
_______________________________________________________________

	Что потребуется для сборки:
	
	* Любой поддерживаемый компиллятор или среда разработки (см. выше).
	* Библиотека Boost: http://www.boost.org/ рекомендую 1.66.0 или возможно выше. Собирается
и на 2008 и на 2015 и на 2017 студии, с 1.65.0 были проблемы. Boost должен быть собран с
использованием либо iconv либо icu (см. ниже)
	* Библиотека ICU (для Boost): http://site.icu-project.org/ Тестировалось с версиями 4.4.2,
59.1, 60.2. Библиотека сильно раздута по сравнению с iconv и при прочих равных лучше
использовать последний.
	* Библиотека iconv (альтернатива icu для Boost): http://www.gnu.org/software/libiconv/
Тестировалось с версией 1.15 и только в MinGW. Также эта библиотека нужна для сборки GDAL
под MinGW (но не нужна под Visual Studio).
	* Библиотека GDAL: http://www.gdal.org/ Тестировалось на версиях 2.2.1 и 2.2.3
	* Альтернативно - на сайте программы возможно есть в наличии набор из уже скомпиллированных
библиотек для нужного компиллятора - проверьте на http://personal.sagrer.ru/tracs/geoimgconv .
Но вы всегда можете скачать исходники этих библиотек и собрать их самостоятельно, следуя
инструкции ниже.
	* CMake: https://cmake.org/ версии не ниже 3.2, желательно 3.10 и выше. Если для сборки будет
использоваться Boost версии 1.66 или выше (например если уже скомпилированные библиотеки
скачивались с сайта этой программы) - CMake _должен_ быть не ниже версии 3.10, иначе он Boost
не найдёт :(. В процессе установки cmake предложит добавить путь к своим исполнимым файлам
в PATH - обязательно принимаем это предложение. Либо делаем это затем руками. cmake обязательно
должен быть виден из командной строки windows.
_______________________________________________________________

	О пакетных менеджерах.
	
	Я думал о том чтобы воспользоваться msys или vcpkg для того чтобы подтягивать требуемые
библиотеки, но пока решил ими не пользоваться т.к. всё что мне пока удалось найти - прибито
гвоздями к какому-то одному компиллятору, а мне хотелось бы чтобы исходник собирался максимально
универсально. Именно этим обусловлены результаты велосипедостроительства, которые вы можете
наблюдать ниже.
	В прочем, в порядке эксперимента сборка в msys2 тестировалась и даже почти работает, но
распространять под Windows мне удобнее всё же версию, собранную с самостоятельно скомпиллированными
библиотеками, т.к. тот же GDAL в MSYS2 собран с огромной кучей зависимостей и адекватно установить
собранный таким образом geoimgconv без установки msys2 на пользовательский компьютер будет
достаточно проблематично. Жаль, что под венды нет действительно универсального пакетного менеджера.
_______________________________________________________________

	Настройка окружения.
	
	Стандартных путей для установки dev-версий библиотек (*.lib, *.h-файлов и прочего
подобного) в Windows не определено. Кроме того, хотелось бы чтобы библиотеки, собранные
одним и тем же компиллятором лежали в своей директории, отдельно от собранных другим
компиллятором - во избежание различных неприятных и труднонаходимых эффектов при линковке
программы, собранной одним компиллятором с библиотеками, собранными другими компилляторами.
	Поэтому нужно создать новую пустую директорию для выбранного компиллятора. Пусть это
будет папка по пути, скажем, C:\DevLibs\vs2017 - для 2017 студии. Аналогично можно создать
например каталог C:\DevLibs\vs2015 для 2015 студии соответствено - в случае если планируется
использовать сразу несколько компилляторов на одном компьютере. Для mingw рекомендуется давать
каталогу имя вроде mingw32 или muingw64.
	Внутри таких директорий сборочные скрипты создадут каталоги bin, include и lib, что
в принципе соответствует тому, как раскладываются dev-версии библиотек при установке их в linux.
	Путь к данному каталогу будет скармливаться CMake чтобы он мог автоматически найти все
нужные для сборки библиотеки. По этому же пути будут устанавливаться сами библиотеки после их
сборки из исходников, ну или после скачивания уже заранее скомпиллированных бинарников.
	Чтобы скрипты смогли найти этот путь - его надо указать в переменной окружения (желательно
на системном уровне, но и уровень пользователя подойдёт).
	Да, на всякий случай стоит всё-же сказать что папки, каталоги и директории - это здесь,
далее по тексту и выше по тексту если найдётся - синонимы, обозначают одно и то же %).

	Как установить переменную окружения (если вдруг кто-то не знает):
	"Проще" всего это сделать стандартными средствами Windows: тыркаем ПКМ (правой кнопкой мыши) по
значку Компьютер, там выбираем "свойства". Появится окно "Система" панели управления (старой,
"классической" в терминологии Windows 10). В это же окно на Win10 (если не выведен значок компьютера
на рабочий стол) можно попасть через меню Пуск->Параметры (кнопка с зубчатым колесом), там выбрать
"Система", далее слева пункт "О системе", затем справа ссылка "Сведения о системе".
	Затем нажимаем слева ссылку "Дополнительные параметры системы" (уровень вложенности уже похож
на анекдот) и, наконец, попадаем на древнейший исторический слой времён Windows 95 наверное - окно
"Свойства системы". Там на вкладке "Дополнительно" (она открывается по умолчанию) внизу справа есть
волшебная кнопка "Переменные среды". Она то нам и нужна. Смело нажимаем и получаем окошко, разделённое
на 2 половины. Наверху - переменные среды пользователя. Внизу - переменные среды системы.
	Эти переменные сохраняются после перезагрузки и там удобно хранить постоянные настройки для
различных скриптов. Создавать переменные рекомендую на уровне системы.
	Да, а когда-то в "Свойства системы" можно было попасть одним кликом :(.

	Итак, указываем путь к созданному ранее каталогу. Имя переменной будет различаться в
зависимости от выбранного компиллятора. Возможные имена переменных:
	* DevLibsVs2008 - для библиотек, собранных Visual C++ 2008. Больше не поддерживается.
	* DevLibsVs2015 - для 32-битных библиотек, собранных в Visual Studio 2015.
	* DevLibsVs2015_x64 - для 64-битных библиотек, собранных в Visual Studio 2015.
	* DevLibsVs2017 - для 32-битных библиотек, собранных в Visual Studio 2017.
	* DevLibsVs2017_x64 - для 64-битных библиотек, собранных в Visual Studio 2017.
	* DevLibsMingw32 - для 32-битных библиотек, собранных в MinGW.
	* DevLibsMingw64 - для 64-битных библиотек, собранных в MinGW.
	
	Путь в переменную записываем без последнего слеша.
	
	Теперь нужно убедиться, что скрипты смогут найти путь к вашему компиллятору. Visual Studio до
2015 версии включительно - создавали на уровне системы переменную окружения с соответствующим путём.
Для 2008 студии это была переменная VS90COMNTOOLS, для 2015 - VS140COMNTOOLS.
	Если такая переменная у вас существует (поискать можно во всё том же окошке), и там указан
актуальный путь типа C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\Tools\ - значит
всё ок. Если переменной нет, но у вас 2017 студия - тоже всё ок, главное чтобы она была обновлена
до самой свежей версии (механизм поиска пути через vswhere разработчики добавили туда не сразу).

	Несколько слов о 64-битной версии. Сборка x64-версии программы поддерживается для 2015 и 2017 студий.
И x32 и x64-версии собираются одним и тем же компиллятором, различаются только настройки запуска сборки.
Но, что логично - библиотеки также должны быть собраны в той же разрядности. Поэтому имеем по 2 разных
переменных для каждой студии. Достаточно указать какую-то одну. Если указаны обе - они должны
содержать путь к разным каталогам.
	Для MinGW - всё аналогично.
	64-битность не только позволяет программе потребить больше 4 гигабайт памяти, но и ускоряет
некоторые критичные кусочки кода, к примеру файлы с пикселями размером в 8 байт (64 бита) обрабатываются
в 64-битной версии быстрее, вероятно это связано с размером регистра. Кроме того, в 64-битной версии
практически не встаёт проблема фрагментации адресного пространства, которая весьма мешает в 32-битной
версии и, соответственно, не позволяет эффективно использовать весь доступный объём памяти.
	Поэтому если возможно - выбирайте 64 бита. Это действительно лучше.
_______________________________________________________________

	Установка и настройка msys2.
	
	Этот раздел актуален, если вы собираетесь собирать программу с помощью MinGW. MSYS2 был выбран как
наиболее поддерживаемый вариант с, наверное, наиболее полноценным репозиторием пакетов. Немаловажно и то,
что для всех нужных библиотек нашлись сборочные скрипты для пакетного менеджера, что очень помогло при
разработке самодельных (не зависящих от системы пакетов MSYS2) сборочных скриптов для этих библиотек.
	Помимо MSYS2 рекомендую установить также Code::Blocks, т.к. именно для этой IDE скрипты генерируют
файл проекта.

	Итак:
	* Идём на https://www.msys2.org/ . Скачиваем пакет под вашу разрядность. Скачивать нужно, условно
говоря, "максимальную" разрядность, т.е. если вы хотите собирать и 64-битную и 32-битную версии
то скачивать надо 64-битный вариант. Разрядность самого MSYS2 определяет разрядность именно среды,
в которой функционируют все входящие в MSYS2 программы, но не определяет разрядность кода, который
компиллируется в ней. Т.е. возможно установить 32-битную версию msys на 32-bit-only операционную систему
и при этом иметь возможность компиллировать (но не запускать) 64-битные исполнимые файлы. Уже после
установки MSYS2 можно будет доустановить нужные версии компилляторов (в частности mingw32 и mingw64).
	* Настоятельно рекомендую ознакомиться с документацией MSYS2, которую можно найти на wiki проекта:
https://github.com/msys2/msys2/wiki . Но для тех, кому лень разбираться - проясню наиболее важные моменты.
		* Во-первых, MSYS расшифровывается как Minimal System и представляет из себя что-то вроде
минимальной имитации UNIX-системы, работающей в Windows и позволяющей собирать и запускать программы,
которые просто так в Windows не работают. У MSYS есть существенное отличие от весьма похожей cygwin.
Последний нацелен именно на создание и использование внутри windows unix-подобной среды,
соответственно, cygwin-программы в общем случае просто так вне cygwin работать не могут. В противоположность
этому программы в MSYS2 могут быть собраны так, что они будут способны нормально работать в родной
windows-среде, т.е. они нормально работают с форматом путей к файлам, принятом в Windows, им не
требуется наличие в системе стандартных unix-путей и стандартных файлов\каталогов, лежащих по этим путям
и т.д.
		* Во-вторых, среда MSYS2 делится как бы на 3 отдельные подсистемы. Первая - собственно MSYS2.
Программы, относящиеся к этой подсистеме во многом похожи на программы из cygwin и вне unix-среды работать
обычно не могут. Две других подсистемы - это mingw32 и mingw64, названия которых говорят сами за себя.
Относящиеся к ним программы и библиотеки собраны таким образом, что могут работать в "чистой"
windows-среде, т.е. вне MSYS2.
		* В-третьих, в репозитории пакетов для MSYS2 содержатся в т.ч. и одноимённые пакеты для всех
этих трёх подсистем, и их можно устанавливать\удалять отдельно. Т.е. надо чётко понимать что в MSYS
есть сама среда и что-то вроде двух "песочниц" - одна 32-битная и вторая 64-битная. У каждого
варианта есть своя особая версия консоли (в меню Пуск обычно создаются ярлыки для вызова консоли
каждого вида). У каждого варианта - свой набор переменных окружения. Что характерно - программы,
установленные в виде msys2-пакетов доступны из консолей mingw32 и mingw64 - это бывает нужно для
корректной работы сборочных скриптов и make-файлов. Но библиотеки, с которыми будет линковаться
собираемая программа - надо устанавливать в виде пакетов именно нужной версии, например под mingw64.
		* В-четвёртых - для установки пакетов используется пакетный менеджер pacman. Арчеводы будут рады.
Подробности как им пользоваться - см. документацию.
	
	* Итак. Устанавливаем msys2. Запускаем её консоль и выполняем команду (без кавычек) "pacman -Syu".
Дальше следуем инструкциям. При необходимости (если pacman об этом попросит) - закрываем консоль,
запускаем её заново и командуем "pacman -Su". Это обновит до последних версий основные пакеты msys2.
	* Устанавливаем нужную версию mingw. Для 64-битной версии командуем "pacman -S mingw-w64-x86_64-toolchain",
а для 32-битной "pacman -S mingw-w64-i686-toolchain". Это имена групп пакетов, pacman спросит
устанавливать ли ему все пакеты из группы - соглашаемся.
	* Если вы собираетесь самостоятельно собирать библиотеки - помимо этого придётся установить ещё
несколько пакетов - командуем "pacman -S base-devel". Это набор всяких разных утилит типа sed и patch.
	* ОБЯЗАТЕЛЬНО нужно добавить путь к установленному MSYS2 в переменные окружения. Если, например,
msys2.exe у вас находится по пути C:\msys2\msys2.exe - надо поставить для переменной окружения
msysdir значение "C:\msys2" (без кавычек). Как добавлять в windows переменные окружения уже расписано выше.
______________________________________________________________

	Библиотеки.
	
	Вы можете выбрать из двух с половиной вариантов:
	1) Взять готовые, уже скомпилированные библиотеки. Об этом - см. следующий раздел.
	2) Скомпиллировать библиотеки самостоятельно. Об этом расскажет раздел, следующий
за следующим :).
	2.5) Использовать готовые библиотеки из msys2. Чисто теоретически - вы можете
установить нужные msys2-пакеты, затем либо попытаться запустить сборочный скрипт для
сборки через mingw, либо даже зайти mingw32 или mingw64-консолью в каталог с исходником
и скомандовать make, как будто вы находитесь в linux. Это может сработать. А может и не
сработать. Такие дела.
______________________________________________________________

	Установка прекомпиллированных библиотек.
	
	Этот вариант позволяет сэкономить кучу времени, но неприменим если вы хотите воспользоваться
иной версией библиотек (или иными параметрами их сборки), либо если не доверяете чужим бинарникам
и хотите собрать всё сами. Ну или просто не нашли версию для вашего компиллятора.

	Просто скачайте с сайта программы комплект библиотек под ваш компиллятор, распакуйте
полученный архив. Затем вынутую из архива папку с именем вроде vs2015 - нужно положить по такому
пути, чтобы на неё указывала созданная по инструкции выше переменная окружения.
	Это всё :).
_______________________________________________________________

	Вариант для истинных красноглазиков. Сборка и установка библиотек
из исходников.
	
	Возможно вы хотите собрать библиотеки с другими параметрами. Или у вас какой-то экзотичный
компиллятор. Или вы просто не смогли найти прекомпиллированную версию для вашей Visual Studio 2032
по причине того, что программа не поддерживается уже много лет. В любом случае, приготовьтесь
потратить на сборку несколько часов. Хотя, если в вашем 2032+ на сборку Boost всё ещё нужно несколько
часов - с миром явно что-то не так :(.

	Итак, вы создали каталог для хранения установленных dev-версий библиотек и указали путь на
него в переменной окружения. Теперь создайте ещё один каталог - там будут лежать исходники
библиотек и сборочные скрипты. Туда сразу же нужно скопировать содержимое каталога сборочных
скриптов из DevScripts\WinDepsBuild данного (этой программы!) дерева исходников.
	Теперь соберём отдельные библиотеки, о чём ниже.
_______________________________________________________________

	Сборка ICU.
	
	Для Visual Studio 2015 и 2017 подойдёт скорее всего любая современная версия библиотеки.
Я тестировал на версииях 59.1 и 60.2. Скачиваем её с http://site.icu-project.org/, распаковываем
содержимое архива в нашу папку для исходников библиотек, пусть лежит рядом со скриптами в отдельном
каталоге. Скорее всего там будет каталог icu, внутри которого должны присутствовать папки packaging
и source.
	Для Visual Studio 2008 последняя подходящая версия - 4.4.2. Её придётся искать в архиве
старых версий. Либо скачать у меня с сайта.
	Для MinGW можно собрать и ICU (скрипты должны работать), но вам в любом случае придётся собирать
iconv т.к. от него во-первых безусловно зависит MinGW-версия GDAL, а во-вторых по умолчанию сборочные
скрипты собирают под MinGW Boost слинкованным с iconv а не с icu. Таким образом, ICU для MinGW-сборки
не нужен и даже вреден, т.к. занимает много места, к тому же плохо влияет на фрагментацию памяти
на 32 битах.

	ВАЖНО: Каталог с исходником библиотеки _должен_ называться icu, либо он может называться иначе,
но придётся предварительно открывать вызываемые скрипты и менять там имя каталога в параметре SRCDIR.
Сборочные скрипты должны лежать рядом с каталогом icu а не внутри него.

	Сборка под Visual С++ 2008 Express.
	Для vs2008 нет сборочного скрипта, т.к. разработчики библиотеки для сборки под студией дают только
sln-файлы, а в Express-версию студии программку для запуска сборки из консоли скриптом попросту не
положили. Поэтому идём в каталог icu\source\allinone и открываем файлик allinone.sln в 2008й вижле.
Теперь надо запустить сборку сначала для Debug а потом и для Release-конфигураций для всего решения.
Затем нужно убедиться что data собралась правильно (о чём подробнее ниже). Затем можно запускать
скрипт установки - запускаем install_icu_vs2008.bat .

	Сборка под Visual Studio 2015.
	Запускаем сборочный скрипт - файл build_icu_vs2015.bat . Если всё отработает хорошо - запускаем
скрипт установки - install_icu_vs2015.bat

	Аналогичным образом сборка выполняется для всех остальных вариантов:
	* Visual Studio 2015 x64 - файл build_icu_vs2015_x64.bat для сборки и install_icu_vs2015_x64.bat
для установки.
	* Visual Studio 2017 - build_icu_vs2017.bat для сборки и install_icu_vs2017.bat для установки.
	* Visual Studio 2017 x64 - файл build_icu_vs2017_x64.bat для сборки и install_icu_vs2017_x64.bat
для установки.
	* MinGW32 - build_icu_mingw32.bat для сборки и install_icu_mingw32.bat для установки.
	* MinGW64 - build_icu_mingw64.bat для сборки и install_icu_mingw64.bat для установки.

	Важный момент - иногда после сборки библиотека data собирается в stub-варианте - т.е. соответствующая
dll-ка не содержит никаких данных. С такой библиотекой не работают нормально локали. Установочные
скрипты отслеживают этот момент и выдают предупреждение если библиотека весит мало т.е. собралась
в stub-варианте. Помимо этого сборочные скрипты при обнаружении stub-библиотеки после завершения
основной сборки - запускают пересборку проекта makedata в надежде что соберётся правильная версия
Однако всё же есть вероятность того, что stub-версия проскочит до момента установки. Если это просходит
- нужно открыть файл icu\source\allinone\allinone.sln в нужной версии Visual Studio, выбрать там
проект makedata и запустить его пересборку. После пересборки - проверить размер файла
icu\bin\icudt*.dll где звёздочка - несколько символов (номер версии). Если размер файла - несколько
килобайт - это stub-версия. Если же там около десятка или больше мегабайт - это нормальная версия.
	Для Visual C++ 2008 сборочного скрипта нет и этот момент надо контроллировать вручную _всегда_!
	Для MinGW проблема не характерна, скрипты размер файла не проверяют.
_______________________________________________________________

	Сборка iconv.
	
	Сборка iconv тестировалась только для MinGW, т.к. для Visual Studio официально есть только очень старая
версия iconv, и при этом iconv не необходим для VisualStudio-сборок boost и gdal. Но собрать тот же gdal
под MinGW без iconv в то же самое время проблематично, к тому же он позволяет полностью отказаться от ICU.
	В общем, для MinGW собираем только iconv а для Visual Studio только ICU.
	
	Сборка тестировалась для версии 1.15.
	Скачиваем исходник библиотеки с http://www.gnu.org/software/libiconv/
	Распаковываем tar.gz файл, скорее всего там будет каталог с именем libiconv-1.15. Обязательно надо
переименовать его в libiconv либо поменять имя в переменной SRCDIR в сборочных скриптах.
	Запускаем сборочный скрипт, если всё хорошо - затем запускаем скрипт установки. Имена скриптов:
	* MinGW32 - build_iconv_mingw32.bat для сборки и install_iconv_mingw32.bat для установки.
	* MinGW64 - build_iconv_mingw64.bat для сборки и install_iconv_mingw64.bat для установки.
_______________________________________________________________

	Сборка boost.
	
	ВНИМАНИЕ! Сборку boost можно выполнять ТОЛЬКО ПОСЛЕ сборки и установки либо ICU либо iconv! На
этапе конфигурации boost одна из этих библиотек должна быть обнаружена, иначе в boost не будут
нормально работать локали, и программа будет падать при попытке работать с кириллицей!
	Для всех Visual Studio по умолчанию (настроено в сборочном скрипте) boost собирается слинкованным
с ICU. Для MinGW - слинкованным с iconv. При желании в сборочных скриптах можно найти закомментированные
аналоги незакомментированных строк для сборки с другой библиотекой (актуально для MinGW).
	
	Для Visual С++ 2008 наблюдались проблемы с версией 1.65.0. Версии 1.64.0 и 1.66.0 собирались
нормально. Для 2017 студии 1.65.0 и 1.66.0 мусорят сообщениями при сборке, причём по разному, однако
собираются. 1.65 ругается на неизвестный компиллятор а 1.66 наоборот - на то что для такого могучего
компиллятора хорошо бы скачать boost версии новее чем 1.66. Последнее несколько странно, но не смертельно.
Рекомендую использовать boost 1.66.0 или возможно выше.

	Скачиваем нужную версию библиотеки с http://www.boost.org/ и распаковываем содержимое архива
в папку для исходников библиотек. Сборочные скрипты должны лежать в этой же папке (куда распаковываем).
Скорее всего из архива будет вынут каталог с именем вроде boost_1_66_0. Его НУЖНО либо переименовать
в boost, либо открыть соответствующие скрипты и изменить там имя каталога в переменной SRCDIR.
	Сборка и установка для всех поддерживаемых компилляторов выполняется единообразно и просто
- запускаем сборочный скрипт, по его завершению запускаем скрипт установки.
	
	Соответствие имён скриптов компиллятору должно быть понятно интуитивно, но всё же распишу его:
	* Visual C++ 2008 - build_boost_vs2008.bat для сборки и install_boost_vs2008.bat для установки.
	* Visual Studio 2015 - build_boost_vs2015.bat для сборки и install_boost_vs2015.bat для установки.
	* Visual Studio 2015 x64 - build_boost_vs2015_x64.bat для сборки и install_boost_vs2015_x64.bat
для установки.
	* Visual Studio 2017 - build_boost_vs2017.bat для сборки и install_boost_vs2017.bat для установки.
	* Visual Studio 2017 x64 - build_boost_vs2017_x64.bat для сборки и install_boost_vs2017_x64.bat
для установки.
	* MinGW32 - build_boost_mingw32.bat для сборки и install_boost_mingw32.bat для установки.
	* MinGW64 - build_boost_mingw64.bat для сборки и install_boost_mingw64.bat для установки.

_______________________________________________________________

	Сборка GDAL.
	
	Сборка тестировалась на версииях 2.2.1 и 2.2.3 и нормально работала на всех компилляторах.
	
	Скачиваем библиотеку с http://www.gdal.org/ и распаковываем содержимое архива в папку для исходников
библиотек. Сборочные скрипты должны лежать в этой же папке (куда распаковываем). Скорее всего из архива
будет вынут каталог с именем вроде gdal-2.2.3. Его НУЖНО либо переименовать в gdal, либо открыть
соответствующие скрипты и изменить там имя каталога в переменной SRCDIR.

	Сборка и установка для всех поддерживаемых компилляторов выполняется единообразно и просто
- запускаем сборочный скрипт, по его завершению запускаем скрипт установки.
	
	Соответствие имён скриптов компиллятору должно быть понятно интуитивно, но всё же распишу его:
	* Visual C++ 2008 - build_gdal_vs2008.bat для сборки и install_gdal_vs2008.bat для установки.
	* Visual Studio 2015 - build_gdal_vs2015.bat для сборки и install_gdal_vs2015.bat для установки.
	* Visual Studio 2015 x64 - build_gdal_vs2015_x64.bat для сборки и install_gdal_vs2015_x64.bat
для установки.
	* Visual Studio 2017 - build_gdal_vs2017.bat для сборки и install_gdal_vs2017.bat для установки.
	* Visual Studio 2017 x64 - build_gdal_vs2017_x64.bat для сборки и install_gdal_vs2017_x64.bat
для установки.
	* MinGW32 - build_gdal_mingw32.bat для сборки и install_gdal_mingw32.bat для установки.
	* MinGW64 - build_gdal_mingw64.bat для сборки и install_gdal_mingw64.bat для установки.
_______________________________________________________________

	Сборка собственно программы.
	
	Если вы успешно собрали и установили все библиотеки или просто распаковали прекомпиллированную
их версию, добавив путь к ней в соответствующую переменную окружения - можно запускать сборку
самой программы.
	В корневом каталоге с исходными текстами лежит набор скриптов с именами вида build_*.bat где
на месте звёздочки указан компиллятор и разрядность.
	Если предыдущие шаги выполнены правильно, т.е. компиллятор, CMake и библиотеки установлены,
переменные окружения настроены - то достаточно просто запустить нужный bat-файл и дождаться
завершения сборки.
	В корне каталога с исходниками появтся новый каталог с именем вида *_build где звёздочка
означает всё то же самое что и раньше :). Внутри можно будет найти папку с релизной версией
бинарника программы и необходимыми библиотеками.
	Скрипт для автоматического формирования комплекта бинарников для распространения конечному
пользователю пока отсутствует, так что в общем случае - после сборки имеет смысл руками скопировать
содержимое каталога 2bin в каталог где лежит получившийся исполнимый файл программы. Это не
необходимо для запуска программы, но может быть удобно для её использования т.к. программа
консольная и в Windows может быть удобнее запускать bat-файлы а не лезть в этот каталог консолью.