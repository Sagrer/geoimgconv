Версия 0.4.0a
-------------
 * Реализован медианный фильтр алгоритмом Хуанга. Плюс данного фильтра в том, что он в разы увеличивает скорость обработки изображений по сравнению с реализацией "в лоб". Минус - в том, что данный алгоритм не может напрямую работать с изображениями, пикселы которых хранятся в виде чисел с плавающей запятой - требуется квантование этих пикселей по уровням. При достаточно большом количестве уровней (по умолчанию стоит 10000 уровней) - разница между изображением, обработанным алгоритмом Хуанга и изображением, обработанным обычным алгоритмом - практически незаметна, но она всё равно есть. Добавлена новая опция командной строки medfilter.huanglevels, позволяющая указать количество этих уровней. Опция medfilter.algo позволяет выбрать между старым "лобовым" алгоритмом и новым Хуанга. В первом случае этой опции присваивается значение stupid а во втором huang.
 * Добавлена опция, запрещающая "засыпать ямы". Поскольку программа обычно используется для "срезания" с изображений растительности и строений - логично предположить, что если медиана находится выше исходной точки, то изменять исходную точку не нужно. По умолчанию опция medfilter.fillpits отключена и ямы _НЕ ЗАСЫПАЮТСЯ_. Это означает, что поведение программы по умолчанию изменилось. Чтобы обрабатывать изображения так же, как раньше - опцию нужно включить.
 * Исправлено множество ошибок в механизме предсказания количества необходимой для работы памяти. В частности выяснилось, что библиотека GDAL может дополнительно потребить для своих внутренних нужд значительные объёмы памяти, размер которых трудно предсказать. Поэтому делается предположение, что GDAL съест примерно столько же памяти, сколько нужно для хранения в памяти несжатого обрабатываемого куска изображения. Зачастую GDAL потребляет памяти меньше, чем ожидалось, но лучше перестраховаться.
 * Исправлена неточность в работе старого "лобового" алгоритма медианного фильтра. Раньше в апертуре не учитывалась 1 колонка и 1 строка, которые должны были учитываться. Хотя на больших окнах на результат это почти не влияло.
 * Прекращена поддержка возможности сборки программы в Visual Studio 2008. Рекомендуется VS2017 либо MinGW под Windows и gcc в linux.
 * Исходник теперь можно собрать в MSYS2 MinGW (и х32 и х64 версии). Официальная бинарная сборка теперь публикуется именно в варианте, собранном этим компиллятором, т.к. в некоторых местах код работает ощутимо быстрее, чем собранный в Visual Studio (вероятно это связано с более эффективной реализацией сортировки в STL). В частности, в 64-битной версии "лобовой" алгоритм на некоторых форматах данных (например, на изображениях с пикселями float64) работает быстрее примерно на 20%.

Версия 0.3.0a
-------------
 * Файлы теперь могут обрабатываться по кускам, без необходимости загружать их в память целиком. Это позволяет даже с помощью 32-битной версии обрабатывать файлы практически любого размера, а также избавляет от необходимости держать огромный файл подкачки. В момент начала обработки geoimgconv определит, сколько оперативной памяти (планки ОЗУ) есть в наличии и, исходя из этого, выберет размер блока, которыми будет обрабатываться картинка. По умолчанию geoimgconv будет использовать 80% оставшегося свободным на момент запуска ОЗУ, а если оперативной памяти будет не хватать - спросит можно ли использовать подкачку. Однако, 32-битная версия имеет серьёзные ограничения, связанные с фрагментацией адресного пространства и необходимостью выделять в нём большие непрерывные блоки. Поэтому на 32-битной Windows geoimgconv сможет использовать не более 900 мегабайт ОЗУ. На 64-битной системе возможно использовать до 2 гигабайт, но на 64-битной системе лучше использовать 64-битный geoimgconv, т.к. там проблема фрагментации в обозримом будущем не должна возникнуть, а программе в современных операционных системах доступно до 7-8 терабайт, а возможно и больше. Имеется и ещё одно ограничение - при обработке вся картинка делится на блоки высотой в примерно половину окна фильтра и шириной в (ширина исходного изображения + удвоенная высота такого блока). Если в память по тем или иным причинам не помещается хотя-бы 3 таких блока - программа работать не сможет. Опять же, для 64-битнй версии эта проблема может возникнуть только при совсем нереально огромных размерах исходного изображения.
 * Потребление памяти можно достаточно тонко настроить новой опцией командной строки --memmode. Подробности - смотри в readme.txt и встроенной справке.
 * Справка теперь более-менее корректно выводится в т.ч. и в linux-версии (раньше выводилась очень узким столбиком при многобайтной кодировке в терминале).
 * В процессе работы выводится приблизительное время, оставшееся до завершения обработки файла. Время оценивается достаточно неточно и постоянно плавает, т.к. рассчитывается исходя из скорости в данный конкретный момент, более точная оценка, возможно, появится в следующих версиях.
 * Программа стала адекватно реагировать на непонятные ей опции командной строки.
 * Справку теперь можно увидеть не только по опциям --help и -h, но и -?.
 * Изменена система нумерации версий на случай если у меня когда-нибудь дойдут руки прикрутить автоматическую генерацию номера версии исходя из количества коммитов в git с момента прошлого выпуска. Для этого пришлось сместить номер выпуска на 1 элемент влево.
 * Бинарники под Windows собираются на Visual Studio 2017 Community Edition. В 64-битном и 32-битном исполнениях.
 * В linux теперь можно сделать make install и make uninstall. Требует прав суперпользователя.
 * Исправлены неисчислимые мелкие ошибки.
 * Добавлены новые.

Версия 0.0.2a
-------------
 * Программа больше не выделяет избыточную память при загрузке картинки.
 * Отключена регистрация всех драйверов GDAL - теперь подключается только один нужный драйвер. Возможно, это уберёт проблему с попыткой подключить непонятные левые драйвера не той разрядности, если они уже были в системе и на них была настроена переменная окружения.
 * Программа собирается под 64 бита на вендах (2015 студия). Код подправлен в местах, где могла быть потеря данных.
 * Добавлена поддержка кириллицы в опциях командной строки и в различных путях. Внутри программы всё преобразуется в utf8 и при необходимости переводится в нужную кодировку при дёргании тех или иных API библиотек, к примеру, boost::filesystem нормально работает только с wchar, тогда как GDAL везде ожидает увидеть utf8, а boost::program_options приводит всё к системной кодировке (т.е. перекодирует командную строку из cp866 в cp1251).

Версия 0.0.1a
-------------
 * Первый релиз.