 = Что это и зачем оно надо =

!GeoImageConverter появился с одной единственной целью - быстро обрабатывать огромные GeoTIFF-картинки с картами высот медианным фильтром. Просто так сложилось что мне нужно было на чём-то попрактиковаться в применении C++, а человека, который попросил меня написать эту программу - окончательно достала та платная программа для обработки геоданных, которой он пользуется на работе. Не буду показывать пальцем, скажу лишь что та самая программа на работе применяет медианный фильтр крайне медленно, хочет много денег, а за возможность обрабатывать изображения размером больше нескольких сотен мегабайт - хочет уже совсем неприлично много денег и несколько компьюьтеров, в распределённом режиме обрабатывающих одну картинку. Найти вменяемую альтернативу тот человек не смог. Я, в силу своего плохого знакомства с предметной областью (картография и всякие разные ГИС) - тоже ничего вменяемого не обнаружил. Следовательно - действительно надо было писать :).

В итоге - появился вот этот вот монстрик, сайт которого вы сейчас и читаете.

Что меня поразило больше всего - даже при совсем тупой реализации медианного фильтра "в лоб" (а это очень ресурсоёмкий алгоритм при большом размере окна) - моя реализация по какой-то непонятной причине работала больше чем на порядок быстрее чем медианный фильтр в платном аналоге. Я не знаю и не хочу знать как именно там оно "напогроммировано", но это очень печально и многое говорит о том, как вообще пишутся в современном мире программы. В прочем, не будем о грустном. Лучше подробнее расскажу зачем при обработке карты высот может понадобиться медианный фильтр.

Во-первых, о самом медианном фильтре. Если не заморачиваться оптимизациями, то алгоритм медианной фильтрации прост как кирпич. У нас есть картинка. Мы последовательно проходим по всем её пикселям. В каждую итерацию - текущий пиксель считается центром "окна" (апертуры) с неким размером (тоже в пикселях). Окно может быть разной формы, но проще всего использовать квадратное (для двумерного массива данных). Берём все попавшие в окно пиксели, находим среди них медианный по значению. И это значение записываем в центр окна, т.е. в текущий пиксел.

Обычно такой фильтр применяют для удаления шумов в изображениях или, например, в каком-нибудь одномерном сигнале, т.к. при небольшом окне он почти не деформирует исходные данные, но убирает резкие пики.

Здесь же (при обработке карт высот) ситуация иная. Я не знаю как называется этот метод в картографии, ибо не имею соответствующего образования, да и мой "заказчик-консультант" говорил что метод этот "не по учебнику" и подобран скорее эмпирически. Но суть такова: им для чего-то надо "срезать" с карт всякие штуки типа домов и деревьев чтобы получить в итоге "голый" рельеф. Можно просто "замазать" леса и домики на карте высот "цветом" (на самом деле уровнем высоты) таким, чтобы замазанная область была примерно на уровне с окружающим рельефом. Но выглядит это не очень красиво, требует много ручной работы, и, как мне говорили, при этом страдает точность карты. Существуют всякие "хитрые" алгоритмы, которые пытаются обнаруживать постройки, лесные массивы, отдельные кустики и всё такое прочее и удалять их, но то ли они не работают, то ли их мало кто умеет правильно "готовить" т.е. настраивать и применять.

Но, как оказалось, у задачи есть очень простое решение - если натравить на картинку медианный фильтр с очень большим окном (сотни пикселей), при этом настроив в фильтре некий пороговый уровень (если медиана отличается от оригинального пикселя меньше чем на порог - пиксель вообще не изменяется) - небольшие домики и кустики срезает начисто, получаем красивый и аккуратный результат:

[[Image(htdocs:img/Before_01_mini.jpg, link=htdocs:img/Before_01.png, title="До фильтра")]]

[[Image(htdocs:img/After_01_mini.jpg, link=htdocs:img/After_01.png, title="После фильтра")]]

С большими зданиями и крупными лесными массивами сложнее - они превращаются вот в такие холмы (окно фильтра 101 пиксель):

[[Image(htdocs:img/Before_02_mini.jpg, link=htdocs:img/Before_02.png, title="До фильтра")]]

[[Image(htdocs:img/After_02_mini.jpg, link=htdocs:img/After_02.png, title="После фильтра")]]

Помочь тут может вероятно только увеличение размера окна, однако чем более неровный рельеф тем больше это будет в свою очередь вносить искажений. Вот пример того же места, но при применении окна размером в 201 пиксель:

[[Image(htdocs:img/After_03_mini.jpg, link=htdocs:img/After_03.png, title="После, с окном в 201 пиксель")]]

Вроде бы, помогает, но всё равно применять фильтр нужно с умом. Кроме того, я пока не проверял работу фильтра на изображениях с чем-то вроде глубокого но узкого оврага или реки - вероятно фильтр нужно дорабатывать так чтобы он не "засыпал" такие вещи. Т.е. это в итоге уже и не совсем медианный фильтр получится, а скорее что-то по мотивам и на основе.

На "локациях" с плотной застройкой и одновременно большими лесными массивами - такой способ работает вообще весьма плохо и надо, похоже, применять что-то другое :(.

[[Image(htdocs:img/Before_03_mini.jpg, link=htdocs:img/Before_03.png, title="До фильтра")]]

[[Image(htdocs:img/After_04_mini.jpg, link=htdocs:img/After_04.png, title="После фильтра")]]

Программа в данный момент консольная. В комплекте идёт набор bat-файлов (для Windows, естественно), которые можно подредактировать блокнотом, поменяв настройки запуска, после чего запустить. Пользователи linux по определению будут в состоянии написать аналогичные скриптики сами, если они им понадобятся. Подробнее - см. readme-файл, идущий в комплекте, либо раздел с документацией на этом сайте. 

[[Image(htdocs:img/Interf_01.png, title="Внешний вид программы")]]

Нормальный пользовательский интерфейс - в планах, но пока дальних. Ближайшие планы в данный момент - это во-первых реализовать алгоритм Хуанга (он должен работать значительно быстрее, но пока сложно сказать как оно скажется на качестве), во-вторых сделать работу программы многопоточной, что также должно ускорить обработку изображений в разы.