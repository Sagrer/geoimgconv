Данный текст написан на основе статьи "A Fast Two-Dimensional Median Filtering Algorithm" T.S. Huang и соавт., 1977.

  * Проблема граничных пикселей в geoimgconv уже так или иначе решена, поэтому просто обрабатываем заданный кусок изображения.
  * В самом начале работы алгоритма смотрим на максимальное и минимальное (но выше 0) значения высоты, исходя из этого, а также из заданного в настройках программы количества уровней - выбираем шаг, которым будем квантовать уровни высоты для пикселей.
  * Количество уровней квантования по умолчанию 256, но в программе должна быть возможность установить это количество уровней произвольно, ну или хотя-бы сделать его в пределах 65536 уровней (т.е. чтобы в дополнительной матрице элементы были размером в 2 байта).
  * Создаём дополнительную матрицу, размерами (в элементах) совпадающую с основным изображением, копируем туда изображение, квантуя значения пикселей.
  * Создаём пустой массив hist из заданного числа элементов (равного числу уровней) под гистограмму.
  * Создаём переменные: median - текущее значение медианы, elemsLeftMed - количество элементов в гистограмме, которые меньше медианы (т.е. левее её), halfMedPos=((aperture^2)-1)/2 - это позиция в которой должна быть расположена медиана, и это значение будет активно использоваться ниже.
  * До начала основного цикла - считаем что предыдущий пиксель у нас был незначим, и что никакими ухищрениями воспользоваться старой гистограммой нельзя. Вообще, тот факт что картинки обрабатываются "неровные" и там есть незначимые пиксели - это проблема, и на первое время проще всего её решить тупым обнулением гистограммы при встрече с незначимым пикселем, а затем заполнением её на значимом пикселе с нуля. Есть частные случаи, когда после нескольких незначимых пикселей всё-же можно использовать старую гистограмму, выполнив над ней операции сразу нескольких шагов (по числу пропущенных незначимых пикселей), либо выполнив шаг вниз (если следующий значимый пиксель оказался строго ниже предыдущего значимого), но обработку этих частных случаев, думаю, смысл делать будет только после того как алгоритм в общих чертах уже заработает. И делать это можно будет позже, в виде дополнительного улучшения. В общем, пусть пока у гистограммы просто будет флаг значимости, например histIsActual, который на незначимых пикселях сбрасывается в false. Изначально он, получается, тоже false.
  * У нас будут 6 подпрограмм. В идеале они должны инлайниться в основной метод, т.к. вызываться будут часто и затраты на вызов метода нафиг не нужны. Если компиллятор не будет инлайнить - вероятно лучше просто закопипастить их в нужные места основного метода. Итак, подпрограммы:
    * Заполнение гистограммы с нуля. Последовательно проходим по всем пикселям апертуры, заполняя гистограмму. Затем идём по гистограмме слева направо, увеличивая с нуля elemsLeftMed и инкрементируя median пока медиана не будет найдена, т.е. пока (elemsLeftMed + hist[median]) <= halfMedPos.
    * Шаг вправо. Удаляем из гистограммы столбец левее апертуры, на каждом шаге elemsLeftMed-- если пиксел меньше текущей медианы. Затем добавляем в гистограмму последний (самый правый) столбец апертуры, на каждом шаге elemsLeftMed++ если пиксел меньше медианы.
    * Шаг влево. Удаляем из гистограммы столбец правее апертуры, на каждом шаге elemsLeftMed-- если пиксел меньше текущей медианы. Затем добавляем в гистограмму первый (самый левый) столбец апертуры, на каждом шаге elemsLeftMed++ если пиксел меньше медианы.
    * Шаг вниз. Удаляем из гистограммы строку выше апертуры, на каждом шаге elemsLeftMed-- если пиксел меньше текущей медианы. Затем добавляем в гистограмму последнюю строку апертуры, на каждом шаге elemsLeftMed++ если пиксел меньше медианы.
    * Корректировка медианы.
      * Если elemsLeftMed > halfMedPos то медиану надо двигать влево т.е. уменьшать. Крутим цикл пока elemsLeftMed > halfMedPos:
        * median--
        * elemsLeftMed -= hist[median]
      * Иначе, если elemsLeftMed <= halfMedPos крутим цикл пока elemsLeftMed+hist[median] <= halfMedPos (возможно не будет ни 1 итерации если медиана осталась актуальной):
        * elemsLeftMed += hist[median]
        * median++
      * В любом случае теперь - имеем корректную медиану.
    * Пишем пиксел в dest. Запись нового значения пикселя в dest-матрицу с учётом порога. Тут всё думаю очевидно, нет смысла расписывать. Сравниваем с порогом, если отличие меньше - пишем пиксел из source-матрицы, иначе пишем значение медианы с учётом квантования.
  * Перед началом основного цикла histIsEmpty=true; histIsActual=false
  * Начинаем основной цикл, который должен проходить по всем пикселям значимой области. В цикле:
    * Начинаем первый подцикл с движением слева направо пока строка не кончится. Подцикл имеет смысл оформить как отдельный инлайновый метод.
      * Если пиксель незначим - histIsActual = false и идём на следующую итерацию.
      * Если пиксель значим:
        * Если histIsActual то делаем 
		  * "Шаг вправо"
		  * "Корректировка медианы".
		  * "Пишем пиксел в dest".
		  * oldX = X
        * Иначе если !histIsEmpty и Y==oldY, и mod(oldX-X) <= halfMedPos, то:
          * mod(oldX-X) раз крутим цикл:
            * Делаем "шаг вправо"
            * Далем "корректировку медианы"
          * "Пишем пиксел в dest"
          * Запоминаем oldX=X
          * histIsActual=true
        * Иначе если !histIsEmpty и oldX==X и Y==oldY+1 то:
          * Делаем "шаг вниз"
          * Далаем "корректировку медианы"
          * "Пишем пиксел в dest"
          * Запоминаем oldY=Y
          * histIsActual=true
        * Иначе старую гистограмму никак с пользой применить нельзя, поэтому делаем:
          * "Заполнение гистограммы с нуля"
          * "Пишем пиксел в dest"
          * Запоминаем oldX=X; oldY=Y;
          * histIsActual=true
          * histIsEmpty=false;
    * Смотрим, можно ли пойти на шаг ниже (не кончилась ли картинка).
      * Если нельзя - выходим из цикла.
	  * Если можно:
	    * ++Y.
	    * Если пиксель незначим:
	      * histIsActual = false и идём дальше.
        * Если пиксель значим:
	      * Если histIsActual то:
	        * Делаем "шаг вниз".
		    * Делаем "корректировку медианы".
		    * "Пишем пиксел в dest"
		    * oldY = Y
		  * Иначе в любом случае полностью перегенерируем гистограмму:
		    * "Заполнение гистограммы с нуля"
            * "Пишем пиксел в dest"
            * Запоминаем oldX=X; oldY=Y;
            * histIsActual=true
            * histIsEmpty=false; 
	    * Идём по второму подциклу, который точно такой же как первый, но с движением слева направо а не справа налево. Также имеет смысл оформить как отдельный инлайновый метод, но это не может быть тот же метод что и в предыдущем подцикле чтобы не делать там каждый раз проверку направления. Сам метод расписывать смысла нет, он почти такой же как и предыдущий подцикл.
	* ...
    * ???
	* ...
	* PROFIT!
